---
import { getCollection } from "astro:content";

export interface Props {
  showIndividual?: boolean;
  showByAct?: boolean;
  showCumulative?: boolean;
  actFilter?: number;
}

const {
  showCumulative = true,
  actFilter,
} = Astro.props;

// Get all scenes and sort them by act, sequence, and scene_number
const scenes = await getCollection("scenes");
const sortedScenes = scenes.sort((a, b) => {
  if (a.data.act !== b.data.act) return a.data.act - b.data.act;
  if (a.data.sequence !== b.data.sequence)
    return a.data.sequence - b.data.sequence;
  return a.data.scene_number - b.data.scene_number;
});

/**
 * Calculate screentime statistics for scenes
 * @param scenes - Array of scene collection entries
 * @returns Object containing various screentime calculations
 */
function calculateScreentime(scenes: typeof sortedScenes) {
  const scenesByAct = new Map<number, typeof sortedScenes>();
  const actTotals = new Map<number, number>();
  const cumulativeByAct = new Map<number, number>();

  // Group scenes by act and calculate totals
  scenes.forEach((scene) => {
    const act = scene.data.act;
    const pageCount = scene.data.page_count || 0;

    if (!scenesByAct.has(act)) {
      scenesByAct.set(act, []);
    }
    scenesByAct.get(act)!.push(scene);

    const currentTotal = actTotals.get(act) || 0;
    actTotals.set(act, currentTotal + pageCount);
  });

  // Calculate cumulative totals (each act includes all previous acts)
  let runningTotal = 0;
  Array.from(actTotals.keys())
    .sort((a, b) => a - b)
    .forEach((act) => {
      runningTotal += actTotals.get(act) || 0;
      cumulativeByAct.set(act, runningTotal);
    });

  return {
    scenesByAct,
    actTotals,
    cumulativeByAct,
    totalScreentime: runningTotal,
  };
}

const stats = calculateScreentime(sortedScenes);

/**
 * Format minutes into a readable time string
 * @param minutes - Number of minutes
 * @returns Formatted time string (e.g., "1h 30m" or "45m")
 */
function formatTime(minutes: number): string {
  if (minutes < 60) {
    return `${minutes}m`;
  }
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
}
---

<div class="screentime-calculator" x-data="{ expandedActs: new Set() }">
  <!-- Collapsible Act Sections -->
  <section class="act-sections">
    <h3>Screentime by Act</h3>
    {Array.from(stats.scenesByAct.entries())
      .sort(([a], [b]) => a - b)
      .filter(([act]) => !actFilter || act === actFilter)
      .map(([act, actScenes]) => {
        const actTotal = stats.actTotals.get(act) || 0;
        const cumulativeTotal = stats.cumulativeByAct.get(act) || 0;
        return (
          <div class="act-section" x-data="{ isExpanded: false }">
            <button 
              class="act-header"
              @click="isExpanded = !isExpanded"
              :class="{ 'expanded': isExpanded }"
            >
              <div class="act-info">
                <span class="act-title">Act {act}</span>
                <span class="act-stats">
                  {formatTime(actTotal)} 
                  {showCumulative && (
                    <span class="cumulative-note">
                      (cumulative: {formatTime(cumulativeTotal)})
                    </span>
                  )}
                </span>
              </div>
              <svg 
                class="expand-icon" 
                :class="{ 'rotated': isExpanded }"
                width="16" 
                height="16" 
                viewBox="0 0 16 16" 
                fill="currentColor"
              >
                <path d="M4.427 9.573L8 6l3.573 3.573a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708z"/>
              </svg>
            </button>
            
            <div 
              class="act-scenes"
              x-show="isExpanded"
              x-transition:enter="transition ease-out duration-200"
              x-transition:enter-start="opacity-0 max-h-0"
              x-transition:enter-end="opacity-100 max-h-screen"
              x-transition:leave="transition ease-in duration-150"
              x-transition:leave-start="opacity-100 max-h-screen"
              x-transition:leave-end="opacity-0 max-h-0"
            >
              <div class="scene-list">
                {actScenes.map((scene) => (
                  <div class="scene-item">
                    <span class="scene-info">
                      Scene {scene.data.scene_number}: {scene.data.title}
                    </span>
                    <span class="screentime">
                      {formatTime(scene.data.page_count || 0)}
                    </span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        );
      })
    }
  </section>

  <!-- Total Screentime -->
  <section class="total-screentime">
    <div class="total-item">
      <span class="total-label">Total Screenplay Runtime</span>
      <span class="screentime total">{formatTime(stats.totalScreentime)}</span>
    </div>
  </section>
</div>

<style>
  .screentime-calculator {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    padding: 1.5rem;
    margin: 1rem 0;
  }

  .screentime-calculator section {
    margin-bottom: 1.5rem;
  }

  .screentime-calculator section:last-child {
    margin-bottom: 0;
  }

  .screentime-calculator h3 {
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    color: var(--color-text-primary);
    border-bottom: 1px solid var(--color-border);
    padding-bottom: 0.5rem;
  }

  /* Act Section Styles */
  .act-section {
    border: 1px solid var(--color-border);
    border-radius: 6px;
    margin-bottom: 0.75rem;
    overflow: hidden;
  }

  .act-header {
    width: 100%;
    background: var(--color-surface);
    border: none;
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.2s ease;
    text-align: left;
  }

  .act-header:hover {
    background: var(--color-background);
  }

  .act-header.expanded {
    background: var(--color-primary-bg);
    border-bottom: 1px solid var(--color-border);
  }

  .act-info {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .act-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--color-text-primary);
  }

  .act-stats {
    font-size: 0.9rem;
    color: var(--color-text-secondary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .cumulative-note {
    font-size: 0.8rem;
    color: var(--color-text-muted);
    font-style: italic;
  }

  .expand-icon {
    transition: transform 0.2s ease;
    color: var(--color-text-secondary);
  }

  .expand-icon.rotated {
    transform: rotate(180deg);
  }

  /* Act Scenes Container */
  .act-scenes {
    background: var(--color-background);
    overflow: hidden;
  }

  .scene-list {
    display: flex;
    flex-direction: column;
    gap: 0;
    padding: 0.5rem;
  }

  .scene-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem;
    background: var(--color-surface);
    border-radius: 4px;
    border: 1px solid var(--color-border-light);
    margin-bottom: 0.5rem;
  }

  .scene-item:last-child {
    margin-bottom: 0;
  }

  .scene-info {
    font-weight: 500;
    color: var(--color-text-primary);
  }

  .screentime {
    font-family: "JetBrains Mono", monospace;
    font-weight: 600;
    color: var(--color-accent);
    background: var(--color-accent-bg);
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.9rem;
  }

  /* Total Screentime Styles */
  .total-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    background: var(--color-primary-bg);
    border: 1px solid var(--color-primary);
    border-radius: 6px;
    font-size: 1.1rem;
  }

  .total-label {
    font-weight: 600;
    color: var(--color-text-primary);
  }

  .screentime.total {
    font-size: 1.1rem;
    background: var(--color-primary-bg);
    color: var(--color-primary);
    border: 1px solid var(--color-primary);
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .screentime-calculator {
      padding: 1rem;
    }

    .act-header {
      padding: 0.75rem;
    }

    .act-info {
      gap: 0.125rem;
    }

    .act-title {
      font-size: 0.95rem;
    }

    .act-stats {
      font-size: 0.85rem;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.25rem;
    }

    .scene-item {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
      padding: 0.5rem;
    }

    .screentime {
      align-self: flex-end;
      font-size: 0.85rem;
    }

    .total-item {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
      padding: 0.75rem;
    }

    .screentime.total {
      align-self: flex-end;
    }
  }
</style>

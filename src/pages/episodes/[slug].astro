---
import { getCollection, getEntry } from "astro:content";
import Layout from "@/layout/Layout.astro";
import "@/styles/screenplay.css";
import { calcEpisodeRuntime } from "@/utils/screenplay/calcEpisodeRuntime.ts";

import Screenplay from "@/components/screenplay/Screenplay.astro";
import Scene from "@/components/screenplay/Scene.astro";
import Action from "@/components/screenplay/Action.astro";
import Character from "@/components/screenplay/Character.astro";
import Dialogue from "@/components/screenplay/Dialogue.astro";
import Parenthetical from "@/components/screenplay/Parenthetical.astro";
import Transition from "@/components/screenplay/Transition.astro";
import ActBreak from "@/components/screenplay/ActBreak.astro";
import PageBreaker from "@/components/screenplay/PageBreaker.astro";
import PrintToPdf from "@/components/PrintToPdf.astro";
import EpisodeNav from "@/components/EpisodeNav.astro";


/**
 * Static paths for all episodes
 */
export async function getStaticPaths() {
  const episodes = await getCollection("episodes");

  return episodes.map((ep) => ({
    params: { slug: ep.slug },
    props: { slug: ep.slug },
  }));
}

const { slug } = Astro.props;

/**
 * Load episode entry
 */
const episode = await getEntry("episodes", slug);
if (!episode) throw new Error(`Episode not found: ${slug}`);

/**
 * Resolve ordered scenes exactly as declared in episode frontmatter
 */
const scenes = await Promise.all(
  episode.data.scenes.map((sceneRef) => getEntry(sceneRef))
);

const resolvedScenes = scenes.filter(
  (s): s is NonNullable<typeof s> => s !== null && s !== undefined
);

/**
 * Collect unique characters across episode
 */
const characterRefs = new Set<string>();
for (const scene of resolvedScenes) {
  for (const charRef of scene.data.characters) {
    characterRefs.add(JSON.stringify(charRef));
  }
}
const characters = await Promise.all(
  [...characterRefs].map((ref) => getEntry(JSON.parse(ref)))
);
const sortedCharacters = characters
  .filter((c): c is NonNullable<typeof c> => Boolean(c))
  .sort((a, b) => a.data.name.localeCompare(b.data.name));

/**
 * Collect unique locations across episode
 */
const locationRefs = new Set<string>();
for (const scene of resolvedScenes) {
  const locs = Array.isArray(scene.data.location)
    ? scene.data.location 
    : [scene.data.location];
  for (const locRef of locs) {
    locationRefs.add(JSON.stringify(locRef));
  }
}
const locations = await Promise.all(
  [...locationRefs].map((ref) => getEntry(JSON.parse(ref)))
);
const sortedLocations = locations
  .filter((l): l is NonNullable<typeof l> => Boolean(l))
  .sort((a, b) => a.data.name.localeCompare(b.data.name));

/**
 * Render scene MDX
 */
const renderedScenes = await Promise.all(
  resolvedScenes.map(async (scene) => ({
    scene,
    Content: (await scene.render()).Content,
  }))
);

// Calculate runtime dynamically
const calculatedRuntime = calcEpisodeRuntime(scenes);

---

<Layout title={`Episode ${episode.data.episode_number} â€“ ${episode.data.title}`}>
  <div class="episode-header">
    <div class="episode-meta">
      <h1>
        Episode {episode.data.episode_number}: {episode.data.title}
      </h1>

      <div class="meta-info">
        <span class="scene-count">
          {resolvedScenes.length} Scenes
        </span>

        {episode.data.estimated_runtime && (
          <span class="runtime">
            ~{episode.data.estimated_runtime} min
          </span>
        )}
        {calculatedRuntime && (
          <span class="runtime">
            {calculatedRuntime} pages
          </span>
        )}
        <PrintToPdf />
      </div>
    </div>

    <div class="episode-details">
      {episode.data.logline && (
        <p class="logline">{episode.data.logline}</p>
      )}

      <div class="detail-section">
        <strong>Locations:</strong>
        <div class="tag-list">
          {sortedLocations.map((loc) => (
            <a href={`/locations/${loc.slug}`} class="tag location-tag">
              {loc.data.name}
            </a>
          ))}
        </div>
      </div>

      <div class="detail-section">
        <strong>Characters:</strong>
        <div class="tag-list">
          {sortedCharacters.map((char) => (
            <a href={`/characters/${char.slug}`} class="tag character-tag">
              {char.data.name}
            </a>
          ))}
        </div>
      </div>
    </div>
    <EpisodeNav currentSlug={episode.slug} />
  </div>

  <div class="screenplay-container"> 
    <div class="screenplay-root">
      <div class="screenplay-page">
        {renderedScenes.map(({ scene, Content }) => (
          <div
            class="scene-break"
            id={`scene-${scene.data.scene_number}`}
          >
            <Content
              components={{
                Screenplay,
                Scene,
                Action,
                Character,
                Dialogue,
                Parenthetical,
                Transition,
                ActBreak,
              }}
            />
          </div>
        ))}
      </div>
      <EpisodeNav currentSlug={episode.slug} />
    </div>
  </div>

  <PageBreaker />

</Layout>

<style is:global>
  @media print {
    @page {
      size: Letter;
      margin: 0;
    }

    html,
    body {
      margin: 0 !important;
      padding: 0 !important;
      background: #fff !important;
      -webkit-print-color-adjust: exact;
      print-color-adjust: exact;
    }

    body > header,
    body > footer,
    header,
    nav,
    footer,
    .episode-header,
    .back-link,
    .tag-list,
    .episode-details {
      display: none !important;
    }

    main {
      margin: 0 !important;
      padding: 0 !important;
    }

    .screenplay-container {
      margin: 0 !important;
      padding: 0 !important;
    }

    .screenplay-root {
      border: none !important;
      width: 8.5in !important;
      margin: 0 auto !important;
    }

    .screenplay-root .screenplay-page {
      border: none !important;
      margin: 0 !important;
      padding-top: 1in !important;
      padding-bottom: 1in !important;
      min-height: auto !important;
      border-bottom: none !important;
      margin-bottom: 0 !important;
    }

    .screenplay-root .screenplay-page::after {
      display: none !important;
    }
  }
</style>

<style>
  .episode-header {
    max-width: 8.5in;
    margin: 0 auto 2rem;
    padding: 1.5rem;
    background: #f9f9f9;
    border-radius: 8px;
  }

  .episode-meta {
    margin-bottom: 1rem;
  }

  .episode-meta h1 {
    margin: 0 0 0.5rem;
    font-size: 1.75rem;
  }

  .meta-info {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .scene-count,
  .runtime {
    background: #eef2ff;
    color: #1e3a8a;
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    font-size: 0.875rem;
    font-weight: bold;
  }

  .logline {
    font-style: italic;
    margin-bottom: 1rem;
  }

  .episode-details {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .detail-section strong {
    display: block;
    margin-bottom: 0.5rem;
  }

  .tag-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .tag {
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    text-decoration: none;
  }

  .location-tag {
    background: #fff3e0;
    color: #e65100;
    border: 1px solid #ffcc80;
  }

  .character-tag {
    background: #e3f2fd;
    color: #1565c0;
    border: 1px solid #90caf9;
  }

  .scene-break {
    margin-bottom: 2em;
  }

  @media print {
    .episode-header {
      page-break-after: always;
    }
  }
</style>
